<?php

namespace Biblioteca\TegBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Tools\Pagination\Paginator;


/**
 * tegRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class tegRepository extends EntityRepository
{
	/**
	 * Our new getAllPosts() method
	 *
	 * 1. Create & pass query to paginate method
	 * 2. Paginate will return a `\Doctrine\ORM\Tools\Pagination\Paginator` object
	 * 3. Return that object to the controller
	 *
	 * @param booleam $published true si solo se muestran los publicos, false todos los teg existentes
	 * 
	 * @return \Doctrine\ORM\Tools\Pagination\Paginator
	 */
	public function search($data = null, $published = true)
	{
        printf("<pre>");print_r($data); printf("</pre>");
	    // Create our query bundler
	    $qb = $this->createQueryBuilder('t');
    	if (isset($data['q'])) {
            //$qb->join('t.key_word', 'k', $qb->expr()->like('k.keyWord', "'%".$data['q']."%'"));
// Example - $qb->join('u.Group', 'g', Expr\Join::WITH, $qb->expr()->eq('u.status_id', '?1'))
// Example - $qb->join('u.Group', 'g', 'WITH', 'u.status = ?1')
// Example - $qb->join('u.Group', 'g', 'WITH', 'u.status = ?1', 'g.id')
// public function join($join, $alias, $conditionType = null, $condition = null, $indexBy = null);

            $exprQ = $qb->expr()->orX(
                $qb->expr()->like('t.cota', "'%".$data['q']."%'"),
                $qb->expr()->like('t.titulo', "'%".$data['q']."%'"),
                $qb->expr()->like('t.escuela', "'%".$data['q']."%'"),
                $qb->expr()->like('t.resumen', "'%".$data['q']."%'")//,
                //$qb->expr()->like('t.palabrasClave', "'%".$data['q']."%'")//,
                //$qb->expr()->like('t.autores', "'%".$data['q']."%'"),
                //$qb->expr()->like('t.tutores', "'%".$data['q']."%'")
            );
        }
        else
        {
            $exprQ = $qb->expr()->isNotNull('t.titulo');
        }

        //Si se filtra por Escuela se 
        if (isset($data['escuela'])){
            $exprEscuela = $qb->expr()->eq('t.escuela', "'".$data['escuela']."'");}
        else{$exprEscuela = $qb->expr()->isNotNull('t.escuela');}

        
        //Si rangos de fechas es ignorado
        if (!isset($data['desde']) && !isset($data['hasta'])){
            $exprInteval= $qb->expr()->isNotNull('t.publicacion');}
        else{
            //Si ingreso rango inferior
            if (isset($data['desde'])) {
                $desde = "'".$data['desde']."-1-1'";
            }else{$desde = 't.publicacion';}
            //Si ingreso rango superior
            if (isset($data['hasta'])) {
                $hasta = "'".$data['hasta']."-12-31'";
            }else{$hasta = 't.publicacion';}
            $exprInteval = $qb->expr()->between('t.publicacion', $desde, $hasta);
        }
        //Se unen en AND las codiciones
        $condiciones = $qb->expr()->andX(
                    $qb->expr()->eq('t.published', "'".$published."'"),
                    $exprEscuela,
                    $exprInteval,
                    $exprQ
        );
        
        $qb->where($qb->expr()->andX($condiciones))
        ->orderBy('t.publicacion', 'DESC')->getQuery();

        
	    return $qb;
	}

    /**
     *
     *
     * @param boolean $all, true: se muestra todo los teg
     *                     false: se muestra SOLO las que esten publicas
     * @return Doctrine\ORM\Query $dql   DQL Query Object
     */
    public function findAllQuery($all = true)
    {
        // Create our query
        $query = $this->createQueryBuilder('t');
        
        if ($all){
            $query->orderBy('t.publicacion', 'DESC')->getQuery();
        }
        else{ 
            
            $query->where($query->expr()->eq('t.published', "true"))->orderBy('t.publicacion', 'DESC')->getQuery();

        }

        return $query;
    }
}

/*
    Filtro sobre ArrayCollections, verifica si un stringToFind es semejante a los valores de Array
*/
class LikeFilter {
    private $stringToFind;

    function __construct($stringToFind) {
        /**
         * Reemplaza todos los acentos por sus equivalentes sin ellos 
         **/
        $stringToFind = trim($stringToFind);
        $stringToFind = str_replace( array('á', 'à', 'ä', 'â', 'ª', 'Á', 'À', 'Â', 'Ä'),
            array('a', 'a', 'a', 'a', 'a', 'A', 'A', 'A', 'A'), $stringToFind );
        $stringToFind = str_replace( array('é', 'è', 'ë', 'ê', 'É', 'È', 'Ê', 'Ë'),
            array('e', 'e', 'e', 'e', 'E', 'E', 'E', 'E'), $stringToFind );
        $stringToFind = str_replace( array('í', 'ì', 'ï', 'î', 'Í', 'Ì', 'Ï', 'Î'),
            array('i', 'i', 'i', 'i', 'I', 'I', 'I', 'I'), $stringToFind );
        $stringToFind = str_replace( array('ó', 'ò', 'ö', 'ô', 'Ó', 'Ò', 'Ö', 'Ô'),
            array('o', 'o', 'o', 'o', 'O', 'O', 'O', 'O'), $stringToFind );
        $stringToFind = str_replace( array('ú', 'ù', 'ü', 'û', 'Ú', 'Ù', 'Û', 'Ü'),
            array('u', 'u', 'u', 'u', 'U', 'U', 'U', 'U'), $stringToFind );
        $stringToFind = str_replace( array('ñ', 'Ñ', 'ç', 'Ç'),
        array('n', 'N', 'c', 'C',), $stringToFind );
            $this->stringToFind = $stringToFind;
    }
    /**
     * @param $i cadena donde se buscara la cadena inferior.
     * @return "true" si la substring se encuantre en $i al menos una vez
     * @var $i valor original, $ii string limpia
     */
    function isLike($i) {
        $ii = trim($i);
        $ii = str_replace( array('á', 'à', 'ä', 'â', 'ª', 'Á', 'À', 'Â', 'Ä'),
            array('a', 'a', 'a', 'a', 'a', 'A', 'A', 'A', 'A'), $ii );
        $ii = str_replace( array('é', 'è', 'ë', 'ê', 'É', 'È', 'Ê', 'Ë'),
            array('e', 'e', 'e', 'e', 'E', 'E', 'E', 'E'), $ii );
        $ii = str_replace( array('í', 'ì', 'ï', 'î', 'Í', 'Ì', 'Ï', 'Î'),
            array('i', 'i', 'i', 'i', 'I', 'I', 'I', 'I'), $ii );
        $ii = str_replace( array('ó', 'ò', 'ö', 'ô', 'Ó', 'Ò', 'Ö', 'Ô'),
            array('o', 'o', 'o', 'o', 'O', 'O', 'O', 'O'), $ii );
        $ii = str_replace( array('ú', 'ù', 'ü', 'û', 'Ú', 'Ù', 'Û', 'Ü'),
            array('u', 'u', 'u', 'u', 'U', 'U', 'U', 'U'), $ii );
        $ii = str_replace( array('ñ', 'Ñ', 'ç', 'Ç'),
        array('n', 'N', 'c', 'C',), $ii );
        

        echo "i = ".$i." ------ stringToFind = ".$this->stringToFind."\n";
        return (stristr($ii, $this->stringToFind) !== false);
    }
     
   
}